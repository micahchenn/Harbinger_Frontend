{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\micah\\\\Desktop\\\\Harbinger_Frontend\\\\frontend\\\\src\\\\Components\\\\Protected_Route.jsx\",\n  _s = $RefreshSig$();\n/**\r\n * @file Protected_Route.jsx\r\n * @author Micah Chen\r\n * @date Last Modified: 5/20/2021\r\n * \r\n * Description: This file contains the implementation of the Protected_Route component. This component is used to protect certain routes\r\n * in the application that require user authentication. It checks if the user is authenticated by verifying the JWT access token stored in local storage.\r\n * \r\n * If the access token is not present or is expired, it attempts to refresh the token using the refresh token. If the refresh token is also not present or invalid,\r\n * the user is considered unauthenticated and is redirected to the welcome page.\r\n * \r\n * If the access token is valid and not expired, the user is considered authenticated and is allowed to access the protected route.\r\n */\n\nimport { Navigate, Route } from 'react-router-dom';\nimport { jwtDecode } from 'jwt-decode';\nimport api from '../api';\nimport { ACCESS_TOKEN, REFRESH_TOKEN } from '../Constants';\nimport { useEffect, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction Protected_Route({\n  children\n}) {\n  _s();\n  const [isAuthorized, setIsAuthorized] = useState(null);\n  useEffect(() => {\n    auth().catch(() => setIsAuthorized(false));\n  }, []);\n  const refreshToken = async () => {\n    const refreshToken = localStorage.getItem(REFRESH_TOKEN);\n    try {\n      const res = await api.post(\"/authenticate/token/refresh/\", {\n        refresh: refreshToken\n      });\n      if (res.status === 200) {\n        localStorage.setItem(ACCESS_TOKEN, res.data.access);\n        setIsAuthorized(true);\n      } else {\n        setIsAuthorized(false);\n      }\n    } catch (error) {\n      console.log(error);\n      setIsAuthorized(false);\n    }\n  };\n  const auth = async () => {\n    const token = localStorage.getItem(ACCESS_TOKEN);\n    if (!token) {\n      setIsAuthorized(false);\n      return;\n    }\n    const decoded = jwtDecode(token);\n    const tokenExpiration = decoded.exp;\n    const now = Date.now() / 1000;\n    if (tokenExpiration < now) {\n      await refreshToken();\n    } else {\n      setIsAuthorized(true);\n    }\n  };\n  if (isAuthorized === null) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: \"Loading...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 66,\n      columnNumber: 16\n    }, this);\n  }\n  return isAuthorized ? children : /*#__PURE__*/_jsxDEV(Navigate, {\n    to: \"/welcome\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 69,\n    columnNumber: 38\n  }, this);\n}\n_s(Protected_Route, \"/RbkxiFcbMKahpHiUnYVhfdK+Ww=\");\n_c = Protected_Route;\nexport default Protected_Route;\nvar _c;\n$RefreshReg$(_c, \"Protected_Route\");","map":{"version":3,"names":["Navigate","Route","jwtDecode","api","ACCESS_TOKEN","REFRESH_TOKEN","useEffect","useState","jsxDEV","_jsxDEV","Protected_Route","children","_s","isAuthorized","setIsAuthorized","auth","catch","refreshToken","localStorage","getItem","res","post","refresh","status","setItem","data","access","error","console","log","token","decoded","tokenExpiration","exp","now","Date","fileName","_jsxFileName","lineNumber","columnNumber","to","_c","$RefreshReg$"],"sources":["C:/Users/micah/Desktop/Harbinger_Frontend/frontend/src/Components/Protected_Route.jsx"],"sourcesContent":["/**\r\n * @file Protected_Route.jsx\r\n * @author Micah Chen\r\n * @date Last Modified: 5/20/2021\r\n * \r\n * Description: This file contains the implementation of the Protected_Route component. This component is used to protect certain routes\r\n * in the application that require user authentication. It checks if the user is authenticated by verifying the JWT access token stored in local storage.\r\n * \r\n * If the access token is not present or is expired, it attempts to refresh the token using the refresh token. If the refresh token is also not present or invalid,\r\n * the user is considered unauthenticated and is redirected to the welcome page.\r\n * \r\n * If the access token is valid and not expired, the user is considered authenticated and is allowed to access the protected route.\r\n */\r\n\r\n\r\nimport {Navigate, Route} from 'react-router-dom';\r\nimport {jwtDecode} from 'jwt-decode';\r\nimport api from '../api';\r\nimport {ACCESS_TOKEN, REFRESH_TOKEN} from '../Constants';\r\nimport {useEffect, useState} from 'react';\r\n\r\n\r\nfunction Protected_Route({children}){\r\n    const [isAuthorized, setIsAuthorized] = useState(null);\r\n\r\n    useEffect(() => {\r\n        auth().catch(() => setIsAuthorized(false))\r\n    }, [])\r\n\r\n    const refreshToken = async () => {\r\n        const refreshToken = localStorage.getItem(REFRESH_TOKEN);\r\n        try {\r\n            const res = await api.post(\"/authenticate/token/refresh/\", {\r\n                refresh: refreshToken,\r\n            });\r\n            if (res.status === 200) {\r\n                localStorage.setItem(ACCESS_TOKEN, res.data.access)\r\n                setIsAuthorized(true)\r\n            } else {\r\n                setIsAuthorized(false)\r\n            }\r\n        } catch (error) {\r\n            console.log(error);\r\n            setIsAuthorized(false);\r\n        }\r\n    };\r\n\r\n    const auth = async () => {\r\n        const token = localStorage.getItem(ACCESS_TOKEN);\r\n        if (!token) {\r\n            setIsAuthorized(false);\r\n            return;\r\n        }\r\n        const decoded = jwtDecode(token);\r\n        const tokenExpiration = decoded.exp;\r\n        const now = Date.now() / 1000;\r\n\r\n        if (tokenExpiration < now) {\r\n            await refreshToken();\r\n        } else {\r\n            setIsAuthorized(true);\r\n        }\r\n    };\r\n\r\n    if (isAuthorized === null) {\r\n        return <div>Loading...</div>;\r\n    }\r\n\r\n    return isAuthorized ? children : <Navigate to=\"/welcome\" />;\r\n}\r\n\r\nexport default Protected_Route;"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,SAAQA,QAAQ,EAAEC,KAAK,QAAO,kBAAkB;AAChD,SAAQC,SAAS,QAAO,YAAY;AACpC,OAAOC,GAAG,MAAM,QAAQ;AACxB,SAAQC,YAAY,EAAEC,aAAa,QAAO,cAAc;AACxD,SAAQC,SAAS,EAAEC,QAAQ,QAAO,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAG1C,SAASC,eAAeA,CAAC;EAACC;AAAQ,CAAC,EAAC;EAAAC,EAAA;EAChC,MAAM,CAACC,YAAY,EAAEC,eAAe,CAAC,GAAGP,QAAQ,CAAC,IAAI,CAAC;EAEtDD,SAAS,CAAC,MAAM;IACZS,IAAI,CAAC,CAAC,CAACC,KAAK,CAAC,MAAMF,eAAe,CAAC,KAAK,CAAC,CAAC;EAC9C,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMG,YAAY,GAAG,MAAAA,CAAA,KAAY;IAC7B,MAAMA,YAAY,GAAGC,YAAY,CAACC,OAAO,CAACd,aAAa,CAAC;IACxD,IAAI;MACA,MAAMe,GAAG,GAAG,MAAMjB,GAAG,CAACkB,IAAI,CAAC,8BAA8B,EAAE;QACvDC,OAAO,EAAEL;MACb,CAAC,CAAC;MACF,IAAIG,GAAG,CAACG,MAAM,KAAK,GAAG,EAAE;QACpBL,YAAY,CAACM,OAAO,CAACpB,YAAY,EAAEgB,GAAG,CAACK,IAAI,CAACC,MAAM,CAAC;QACnDZ,eAAe,CAAC,IAAI,CAAC;MACzB,CAAC,MAAM;QACHA,eAAe,CAAC,KAAK,CAAC;MAC1B;IACJ,CAAC,CAAC,OAAOa,KAAK,EAAE;MACZC,OAAO,CAACC,GAAG,CAACF,KAAK,CAAC;MAClBb,eAAe,CAAC,KAAK,CAAC;IAC1B;EACJ,CAAC;EAED,MAAMC,IAAI,GAAG,MAAAA,CAAA,KAAY;IACrB,MAAMe,KAAK,GAAGZ,YAAY,CAACC,OAAO,CAACf,YAAY,CAAC;IAChD,IAAI,CAAC0B,KAAK,EAAE;MACRhB,eAAe,CAAC,KAAK,CAAC;MACtB;IACJ;IACA,MAAMiB,OAAO,GAAG7B,SAAS,CAAC4B,KAAK,CAAC;IAChC,MAAME,eAAe,GAAGD,OAAO,CAACE,GAAG;IACnC,MAAMC,GAAG,GAAGC,IAAI,CAACD,GAAG,CAAC,CAAC,GAAG,IAAI;IAE7B,IAAIF,eAAe,GAAGE,GAAG,EAAE;MACvB,MAAMjB,YAAY,CAAC,CAAC;IACxB,CAAC,MAAM;MACHH,eAAe,CAAC,IAAI,CAAC;IACzB;EACJ,CAAC;EAED,IAAID,YAAY,KAAK,IAAI,EAAE;IACvB,oBAAOJ,OAAA;MAAAE,QAAA,EAAK;IAAU;MAAAyB,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAK,CAAC;EAChC;EAEA,OAAO1B,YAAY,GAAGF,QAAQ,gBAAGF,OAAA,CAACT,QAAQ;IAACwC,EAAE,EAAC;EAAU;IAAAJ,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAE,CAAC;AAC/D;AAAC3B,EAAA,CA/CQF,eAAe;AAAA+B,EAAA,GAAf/B,eAAe;AAiDxB,eAAeA,eAAe;AAAC,IAAA+B,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}